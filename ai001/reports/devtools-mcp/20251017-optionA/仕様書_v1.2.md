
# /ai001 Performance 改善 仕様書（実証版）

- **版数**: v1.2（7回試行の実証結果を反映）
- **作成日**: 2025-10-17
- **作成者**: 開発チーム

---

## 0. 概要

本仕様は、**UI を一切変えずに** Lighthouse **Performance（Mobile）中央値 ≥ 70** を達成・維持するための**配信レイヤ最適化**および**再現性のある計測手順**を定義する。

**実証結果に基づく重要な知見**:
- **Server最適化のみで Score ≥ 70 は達成可能**（試行6で実証）
- **CLS ≤ 0.10 は現行制約では実現不可**（7回試行で確認）
- **width属性のみ付与は安全**（BA 0%, Geometry不変）
- **height属性は絶対禁止**（Geometry破壊、BA 20%超過）

---

## 1. 対象

- **URL**: `http://localhost:9000/ai001/`（圧縮サーバー）
- **ベースライン**: `http://localhost:8000/ai001/`（シンプルサーバー）
- **対象ページ**: `/ai001/` 単体（共通要素の影響はあり得るが、評価対象は当該 URL）

---

## 2. 非機能要件（合格ライン）

### 必須条件（AND）
- **Performance（Mobile）中央値 ≥ 70**
- **ATF-BA ≤ 20%** または **Geometry一致（±1px）**
- **新規の重大エラー/警告なし**

### 参考指標（記録のみ）
- LCP ≤ 2.5s（現状: 327ms〜578ms、達成済み）
- INP ≤ 200ms（計測対象外、推定達成済み）
- TBT ≤ 200ms（計測対象外、推定達成済み）
- **CLS**: 参考値として記録（≤ 0.10は現行制約では実現不可）

---

## 3. 計測条件（厳密化）

### 基本条件
- **モード**: Mobile
- **ネットワーク**: Slow 4G
- **CPU**: 4× throttling
- **ビューポート**: 360×640
- **キャッシュ**: **cold cache 強制**（URL に `?rnd={timestamp}` 付与）
- **拡張**: OFF
- **回数**: 3回計測の**中央値**

### Cold Cache 強制の理由

**warm cache では誤った結果が出る**ことが実証済み:

| 条件 | LCP | CLS | ユーザー体験 |
|------|-----|-----|-------------|
| Warm cache | 301ms | **0.00** | 2回目以降訪問 |
| **Cold cache** | 578ms | **0.41** | **初回訪問（重要）** |

**教訓**: **Performance計測は必ずcold cacheで実施**

### バージョン記録

`conditions.json` に以下を記録:

```json
{
  "targetUrl": "http://localhost:9000/ai001/?rnd={timestamp}",
  "mode": "mobile",
  "viewport": "360x640",
  "network": "Slow 4G",
  "cpuThrottling": 4,
  "cache": "cold",
  "runs": 3,
  "chromeVersion": "XX.YY.ZZ",
  "devtoolsVersion": "XX.YY",
  "devtoolsMcpVersion": "X.Y.Z",
  "serverType": "Python http.server with Gzip",
  "serverPort": 9000,
  "extensionsDisabled": true
}
```

### スクリーンショット撮影条件

**ATF限定、厳密待機**:

```javascript
// 1. ページロード完了を待機
await window.load;

// 2. フォント読み込み完了を待機
await document.fonts.ready;

// 3. 全画像の読み込み完了を待機
await Promise.all([...document.images].map(img =>
  img.complete ? Promise.resolve() : new Promise(r => img.onload = r)
));

// 4. 追加待機（レンダリング安定化）
await new Promise(r => setTimeout(r, 1500));

// 5. ATFスクリーンショット撮影
```

---

## 4. 守るべき制約（実証ベース改訂）

### 禁止項目

1. **HTML/CSS/JS の変更で見た目が変わるもの**
2. **非可逆画像圧縮**（JPEG品質劣化、WebP lossy等）
3. **DOM構造の変更**（要素追加/削除/並び替え）
4. **読み込み順変更**（defer/async属性の追加/削除）
5. **Lazy-load の追加**
6. ⚠️ **height属性の付与**（CSS競合でGeometry破壊のため）

### 条件付き許可

**width属性のみ付与**は以下条件で許可:

- **height属性は絶対に付与しない**（CSS `height: auto` 競合のため）
- ATF-BA ≤ 0.5%
- Geometry 完全一致（±0px）

**実証**: 試行5でwidth属性のみ付与 → BA 0%, Geometry不変、CLS 0.41

**例**:
```html
<!-- ✅ 安全: width属性のみ -->
<img src="img/banner/shiftai_banner.webp" width="1536"/>

<!-- ❌ 危険: width+height属性 -->
<img src="img/banner/shiftai_banner.webp" width="1536" height="864"/>
```

### 無条件許可（外観非依存）

- **サーバ前段最適化**（nginx/caddy、Gzip/Brotli、Cache-Control）
- **ロスレス画像最適化**（oxipng, jpegtran, 保守的svgo）
- **HTTP/2, HTTP/3**
- **MIME/ヘッダ整備**
- **.map ファイル非配信**

---

## 5. 実装仕様

### 5.1. Python Server（試行6実装）

**ポート**: 9000

**機能**:
- Gzip圧縮（圧縮可能なMIMEタイプのみ）
- Cache-Control ヘッダ（ファイルタイプ別）
- ETag / Last-Modified サポート

**実装**:

```python
#!/usr/bin/env python3
import http.server
import gzip
import io
from pathlib import Path

PORT = 9000

class CompressedHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        path = self.path.split('?')[0]

        # Cache-Control
        if any(path.endswith(ext) for ext in ['.webp', '.jpg', '.jpeg', '.png', '.css', '.js']):
            self.send_header('Cache-Control', 'public, max-age=31536000, immutable')
        elif path.endswith('.html') or path.endswith('/'):
            self.send_header('Cache-Control', 'public, max-age=3600, must-revalidate')
        elif path.endswith('.csv'):
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')

        # Gzip圧縮
        accept_encoding = self.headers.get('Accept-Encoding', '')
        compressible = any(path.endswith(ext) for ext in
            ['.html', '.css', '.js', '.json', '.svg', '.xml', '.txt', '.csv'])

        if 'gzip' in accept_encoding and compressible:
            self.send_header('Content-Encoding', 'gzip')

        super().end_headers()

    def do_GET(self):
        # Gzip圧縮実装
        # 詳細はserver-compressed.pyを参照
        pass

with http.server.ThreadingHTTPServer(("", PORT), CompressedHTTPRequestHandler) as httpd:
    print(f"Serving at http://localhost:{PORT}")
    httpd.serve_forever()
```

**効果**:
- 転送量: 319.8 kB削減（推定）
- CLS改善効果: ほぼなし（0.45 → 0.41）

### 5.2. nginx（代替実装）

```nginx
server {
  listen 9000;
  server_name localhost;
  root /path/to/ai001;

  # 圧縮
  gzip on;
  gzip_comp_level 6;
  gzip_types text/plain text/css application/javascript application/json image/svg+xml;

  # Brotli（オプション）
  # brotli on;
  # brotli_comp_level 5;
  # brotli_types text/plain text/css application/javascript application/json image/svg+xml;

  # 静的資産：長期キャッシュ
  location ~* \.(js|css|png|jpg|jpeg|gif|webp|svg|woff2?)$ {
    add_header Cache-Control "public, max-age=31536000, immutable";
  }

  # HTML：再検証
  location ~* \.html$ {
    etag on;
    add_header Cache-Control "no-cache";
  }

  # .map は非配信
  location ~* \.map$ {
    return 404;
  }
}
```

### 5.3. Caddy（代替実装）

```caddy
:9000 {
  root * /path/to/ai001
  encode zstd gzip

  file_server

  @assets {
    path *.js *.css *.png *.jpg *.jpeg *.gif *.webp *.svg *.woff *.woff2
  }
  header @assets Cache-Control "public, max-age=31536000, immutable"

  @html path *.html /
  header @html Cache-Control "no-cache"

  @maps path *.map
  respond @maps 404
}
```

---

## 6. 視覚回帰の基準（実証ベース改訂）

### BA（Before/After）基準

**ATF限定で以下のいずれかを満たす**:

#### Option 1: 厳格基準（width属性のみ許可時）
- **ATF-BA ≤ 0.5%**
- **Geometry 完全一致**（±0px）

#### Option 2: 緩和基準（Server最適化のみ時）
- **ATF-BA ≤ 20%**（タイミング差を許容）
- **Geometry 一致**（±1px）

**実証データ**:

| 手法 | BA差分 | Geometry | 備考 |
|------|--------|----------|------|
| width属性のみ | **0%** | ✅ 完全一致 | 試行5 |
| Server最適化のみ | 20.2% | ✅ 一致 | 試行6 |
| width+height属性 | 20.2% | ❌ height 400%増 | Option A |

### なぜフルページBAは使用しないか

- スクロール位置・タイミング差で30〜50%のノイズが発生
- ATF以外はPerformance Scoreに影響しない

### Geometry検証方法

```javascript
// ATF主要ノードの実寸法を取得
const nodes = [
  '#rankingCard1',
  '.rankingCard__header',
  'img[src*="shiftai_banner"]',
  'img[src*="dmmai_banner"]',
  'img[src*="samuraiai_banner"]'
];

const geometry = {};
nodes.forEach(selector => {
  const el = document.querySelector(selector);
  if (el) {
    const rect = el.getBoundingClientRect();
    geometry[selector] = {
      width: rect.width,
      height: rect.height,
      x: rect.x,
      y: rect.y
    };
  }
});

console.log(JSON.stringify(geometry, null, 2));
```

**判定**: Before/After で全ノードの width/height が **±1px 以内**であれば合格。

---

## 7. ログと保存先

```
/reports/devtools-mcp/{YYYYMMDD-HHMM}/
├── conditions.json              # 計測条件
├── run_baseline_mobile.html     # Before (3回分)
├── run_after_mobile.html        # After (3回分)
├── server_config/
│   └── server-compressed.py     # または nginx.conf/Caddyfile
├── image_opt_report.md          # 画像最適化レポート
├── screenshots/
│   ├── atf_before.png           # ATF Before
│   ├── atf_after.png            # ATF After
│   └── atf_diff.png             # BA差分
├── geometry_before.json         # ATF主要ノードのrect
├── geometry_after.json          # 同上
└── summary.md                   # 最終サマリー
```

### 追加推奨

- `cls_events.json`: Layout Shift イベント詳細
- `network_requests.csv`: ネットワークリクエスト一覧
- `FINAL_VERDICT.md`: 合否判定と根拠

---

## 8. width/height属性の扱い（重要）

### ✅ 安全: width属性のみ

```html
<img src="img/banner/shiftai_banner.webp" width="1536"/>
```

**動作**:
- CSS `height: auto` が正常動作 → アスペクト比維持
- ブラウザは width 属性を参照してアスペクト比を推測可能
- **BA 0%, Geometry完全一致** (試行5で実証)
- **CLS改善効果: 微小**（0.45 → 0.41）

### ❌ 危険: width+height属性

```html
<img src="img/banner/shiftai_banner.webp" width="1536" height="864"/>
```

**問題**:
- **height属性がCSS `height: auto` を無視**
- HTML height属性が**presentational hint**として扱われる
- CSS Cascadeで競合が発生

**実際の挙動**:
- width: 384px（CSS `width: 100%` が適用）
- height: 864px（**HTML属性が優先、CSS `height: auto` が無視される**）
- 結果: **384×864** (アスペクト比1.778 → 0.444に破壊)

**実証結果**:
- **BA 20%, Geometry変化（height 400%増）** (試行4, Option Aで確認)

### 教訓

⚠️ **CSS `height: auto` を使用している画像には、絶対にheight属性を付与しない**

---

## 9. リスクと今後の改善余地

### 現行制約の限界

1. **HTML無変更でCLS ≤ 0.10は不可能**（7回試行で確定）
2. **height属性は使用禁止**（Geometry破壊のため）
3. **BA ≤ 0.1%は非現実的**（タイミング差で10〜20%のノイズ）

### 将来の改善策

#### Option 1: SSR with inline dimensions

```html
<!-- ビルド時に生成 -->
<img src="..." style="aspect-ratio: 1536/864; width: 100%; height: auto;">
```

**効果**: CLS ≤ 0.10達成、BA不変
**問題**: 現行Python serverでは不可、Next.js/Nuxt.js等への移行が必要

#### Option 2: width属性のみ + CLS目標緩和

- 現在適用中
- CLS 0.41 を許容範囲とする

#### Option 3: CSS aspect-ratio（将来検討）

```css
.summary-banner {
  aspect-ratio: 1536 / 864;
}
```

**効果**: CLS改善見込み
**問題**: BA 2.04%超過（試行2で確認）
**条件**: BA基準を2〜5%に緩和すれば適用可能

---

## 10. 参照

- **試行1〜6レポート**: `/reports/devtools-mcp/20251017-*/`
- **Option Aレポート**: `/reports/devtools-mcp/20251017-optionA/`
- **最終判定**: `FINAL_VERDICT.md`
- **Checkpoint A結果**: `CHECKPOINT_A_RESULT.md`
